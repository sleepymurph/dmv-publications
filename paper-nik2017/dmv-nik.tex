\documentclass[
    usenglish,
    % final,
]{nik}

\input{dmv-nik-packages.tex}
\input{dmv-nik-custom-commands.tex}

\title{DMV: Distributed Media Versioning across devices}
\author{Michael J. Murphy \and Otto J. Anshus \and John Markus Bj√∏rndalen}
\date{November 2017}

\begin{document}
\maketitle

\begin{abstract}
\input{dmv-nik-abstract.txt}
\end{abstract}

\section*{OUTLINE}

\begin{verbatim}

- Problem: many devices, more data, difficult to follow what is where

- Cloud not solution. Relies on third party. Connection, privacy, etc.

- DVCS: An alternate approach

    - Extreme availability
    - Version history gives chain of causality for later reconciliation

- Interesting properties of DAG

    - DAG gives de-duplication
    - Content addressing gives tampering/bitrot protection
    - DAG also gives convenient ways to shard data

- Problem 1: dealing with larger files: chunking

    - Bup has chunking but locked into backup workflow

- Problem 2: dealing with many files: packing

    - Git has packing but in separate step that fails for large files

- Problem 3: increasing data: sharding

- In-between: de-duplication

- DMV prototype

- Experiments

    - File size and number of files
    - Random writes

- Results

- Conclusion

    - chunk, content-address, re-pack
    - DMV not yet viable, but it's a start

\end{verbatim}

\section{Introduction}

\towrite{A typical computer user has multiple devices holding an increasing amount of data.}
\towrite{Most users will have at least a computer and a mobile phone.}
\towrite{Many will also have a work computer, tablet, or other devices.}
\towrite{These devices have varying resources, including processing, memory, and storage.}
\towrite{They may also be in different locations, on different networks, or turned off at any time.}
\towrite{The user's data will be in files of varying sizes and media types, from kilobyte text documents to multi-gigabyte videos and beyond.}
\towrite{The volume of data is also always increasing as data is authored, collected from the internet, or gathered from mobile sensors.}
\towrite{This data is strewn across these devices in an ad-hoc fashion, according to where it is produced and consumed.}
\towrite{When the user needs a particular file, they must either remember where it is or perform a frustrating, manual, multi-device search.}
\towrite{Also, copies of data on different devices will diverge if updates are made separately and not reconciled.}

\subsection{Shortcomings of Cloud-Based Solutions}

\towrite{Cloud computing eases these problems by centralizing storage, searching, and update reconciliation.}
\towrite{However, the user's access to their data depends on the reliability of their network connection and the reliability and longevity of the cloud service.}
\towrite{Handing data over to a third party also raises concerns about privacy.}
\towrite{The cloud service may also charge a recurring subscription fee.}
\towrite{The user might prefer to use the devices they already own, provided there is an easier way to manage the data.}

\subsection{Potential of Version Control}

\towrite{This paper explores distributed version control systems as an alternative approach to managing data across a spectrum of devices.}

\written{A DVCS keeps writable copies of a data set at multiple locations, tracks update history, and allows diverging versions to be merged at a later date.}

Git stores its data in a directed acyclic graph (DAG) structure.
Blob objects contain file data;
tree objects store lists of blobs, representing directories;
and a commit objects each associate a particular tree state with metadata such as time, author, and previous commit state, placing that tree state into a history.
Each object is stored in an content-addressed object database, indexed by a cryptographic hash of its contents \cite{git_initial_readme}.
%Mercurial's data is stored differently on disk, but it can still be modelled conceptually with this same data structure \cite[Chapter 4]{hgbook}.

Objects, once stored, are immutable.
Updating an object would change its hash and thus its ID, creating a new object.
Because objects refer to other objects by hash ID, a new object can only refer to a pre-existing object with known content.
The graph is directed because these links flow in one direction, and it is acyclic because links cannot be created to objects that do not exist yet, and existing objects cannot be updated to point to newer objects.
The DAG is append-only.

Such a DAG structure has several interesting properties for data storage.
\begin{description}
    \item[De-duplication]
        Identical objects are de-duplicated because they will have the same ID and naturally collapse into a single object in the data store.
        This results in a natural compression of redundant objects.
        The efficiency of the compression depends on how well identical pieces of data map to independent objects.
        In Git, the redundant objects are the files and directories that do not change between commits.
    \item[A record of causality]
        Copies of the DAG can be distributed and updated independently.
        Concurrent updates will result in multiple branches of history, but references from child commit to parent commit establish a happens-before relationship and give a chain of causality.
        Branches can be merged by manually reconciling the changes, and then creating a merge commit that refers to both parent commits.
        When transferring updates from one copy to another, only new objects need to be transferred.
    \item[Atomic updates]
        When a new commit is added, all objects are added the database first, then finally the reference to the current commit is updated.
        This reference is a 160-byte SHA-1 hash value, and which can be updated atomically.
    \item[Verifiability]
        Because every object is identified by its cryptographic hash, the data integrity of each object can be verified at any time by re-computing and checking its hash.
\end{description}

\towrite{However, version control systems are designed for the small text files of source code and are not suited to larger binary files.}


\section{DMV Architecture and Design}

\towrite{We describe the architecture, design, and implementation of a new system we call Distributed Media Versioning (DMV) that resembles version control but is more flexible.}
\towrite{DMV will allow the user to shard and replicate data across many devices with fine-grained control.}
\towrite{It will keep a unified view of the data set as subsets of the data are copied or moved between devices by user request.}
\towrite{It will allow data to be updated on any device, and it will track history so that}
\towrite{diverging versions can be merged later.}

\begin{figure}[]
    \centering
    \includegraphics[width=0.95\textwidth]{dia_architecture}
    \caption{Repositories in an ad-hoc network}
    \label{fig:dia_architecture}
\end{figure}

\begin{figure}[]
    \centering
    \includegraphics[width=0.9\textwidth]{dia_dmv_dag_example_three_commits}
    \caption{A simple DMV DAG with three commits}
    \label{dia_dmv_dag_example_three_commits}
\end{figure}


\newcommand{\slicediagramwidth}{0.45\textwidth}

\begin{figure}[]

    \centering

    \begin{subfigure}[]{\slicediagramwidth}
        \includegraphics[width=\textwidth]{dia_dmv_dag_slice_partial_history}
        \caption{Partial history of full data set}
        \label{dia_dmv_dag_slice_partial_history}
    \end{subfigure}
    ~
    \begin{subfigure}[]{\slicediagramwidth}
        \includegraphics[width=\textwidth]{dia_dmv_dag_slice_history_of_subset}
        \caption{Full history of part of data set}
        \label{dia_dmv_dag_slice_history_of_subset}
    \end{subfigure}
    ~
    \begin{subfigure}[]{\slicediagramwidth}
        \includegraphics[width=\textwidth]{dia_dmv_dag_slice_history_of_metadata}
        \caption{Full history of metadata}
        \label{dia_dmv_dag_slice_history_of_metadata}
    \end{subfigure}

    \caption{A DMV DAG, sliced in different dimensions}
\end{figure}



\section{Evaluation}

\towrite{We perform experiments to explore the scalability limits of selected version control systems.}
\towrite{We find that the maximum file size is limited by available RAM, and that commit times increase sharply as the number of files increases into the}
\towrite{millions.}
\towrite{We also perform the same experiments against a DMV prototype for comparison.}
\towrite{DMV avoids the file-size limitations by using a rolling hash algorithm to break larger files into smaller chunks.}
\towrite{Unfortunately, our early DMV prototype suffers the same problems with numerous files because it uses the underlying filesystem in a similar way.}

\section{Conclusion}

\towrite{We conclude that the key to processing large files is to break them into many smaller chunks, and the key to storing many small files is to aggregate them into larger packs.}
\towrite{We propose corrective changes for future work on DMV.}


\printbibliography[]

\listoftodos

\end{document}
