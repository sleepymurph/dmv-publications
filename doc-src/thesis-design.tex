\chapter{DMV Design}


\section{DMV's DAG}

The heart of DMV is the directed acyclic graph it uses to store data and
history. DMV's DAG is based on Git's, but it adds a new object type, the
\newterm{chunked blob}, which represents a blob\todo{Consistent capitalization
of "blob"} that has been broken into several smaller chunks. The objects that
make up the DMV DAG are as follows:

\begin{description}

    \item[Blob] As with Git, a blob simply holds binary data.

    \item[Chunked blob] Unlike with Git, larger blobs in DMV are broken into
        chunks. Each chunked blob is simply an index of blobs (or other chunked
        blobs) that make up the larger blob. A file that is stored in the system
        may be represented by a blob or a chunked blob.

    \item[Tree] As with Git, a directory that is stored in the system is
        represented by a tree object. The tree refers to the blob, chunked blob,
        or tree that represents each file or subdirectory, along with metadata
        such as the filename.

    \item[Commit] As with Git, a commit represents a given state of the data
        set. It refers to the tree that represents the top-level directory of
        the data set at that state, along with metadata such as author, date,
        and description. It also refers to the previous commit (or commits) that
        represented the previous state of the data set.

    \item[Ref] As with Git, a ref is a reference to a particular commit. A ref
        might represent the current state of a branch of development, or a
        particular state to save for later (a tag).

\end{description}

The DAG begins with refs. Each repository has a list of refs that lead into the
DAG. Each ref refers to a commit. Each commit refers to a tree that represents
the state at the time of committing, plus one or more parent commits. A tree
refers to the blob, chunked blob, or tree that makes up each entry in the
directory. A chunked blob can refer to other chunked blobs or to blobs. And
finally, the blobs are the leaves of the graph. This relationship is illustrated
in \autoref{fig:dia_new_dag}.


\begin{figure}[h]
    \caption{DMV DAG Object Types}
    \label{fig:dia_new_dag}
    \centering
        \includegraphics[width=0.5\textwidth]{dia_new_dag}
\end{figure}

\missingfigure{Example DMV DAG (Modify visualizer script?)}


\towrite{Low-level}

\towrite{Wide variety of platforms}


\towrite{Not required to store all of the DAG}

\towrite{Subtree commits}

\towrite{Sparse commits}

\towrite{Usage assumptions
    - Assume more reads than writes
    - Assume more appends or rewrites than in-place updates
}


\subsection{What the system should not do}
\todo{Update tense}
\todo{Break this up?}
\todo{Move it to Idea section? As a sidebar?}

We want to focus on the problem of storing file history and synchronizing files
between replicas.
We should be careful not to expand across the wrong abstraction boundaries or to
try to do too much.
In particular:

\begin{itemize}

  \item We do not want to reinvent the filesystem. The system should place and
    update files on the filesystem (or offer a filesystem view, such as with
    FUSE) for applications to use normally. Applications such as editors should
    not have to be rewritten to use our system.

  \item We do not want to create new exotic file formats. We believe that the
    classic tree of files is our best chance for long-term storage.

  \item We hope this system could eventually be used as a piece of
    infrastructure on which to build useful applications. It should not
    incorporate functionality that would better be left to an application.

  \item We do not want to deal with media metadata and categorization. Metadata
    and categorization is best left to the applications that produce and consume
    those media formats. We will merely provide the storage.

  \item However, knowledge of media formats might be used for behind-the-scenes
    optimization such as more efficient compression. E.g. recognizing that only
    tag data has changed in an audio file.

\end{itemize}
