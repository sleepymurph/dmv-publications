\chapter{DMV Design}


\section{DMV's DAG}

DMV's data set and its history are represented as a DAG, and the rest of the
design flows from that. DMV's DAG is based on Git's, but it adds a new object
type, the \newterm{chunked blob}, which represents a blob\todo{Consistent
capitalization of "blob"} that has been broken into several smaller chunks. An
example DMV DAG is shown in \autoref{dia_dmv_dag_example_three_commits}.

\begin{figure}[]
    \centering
    \includegraphics[width=0.9\textwidth]{dia_dmv_dag_example_three_commits}
    \caption{A simple DMV DAG with three commits}
    \label{dia_dmv_dag_example_three_commits}
\end{figure}

The object types that make up the DMV DAG are as follows:

\begin{description}

    \item[Blob] As with Git, a blob simply holds binary data.

    \item[Chunked blob] Unlike with Git, larger blobs in DMV are broken into
        chunks. Each chunked blob is simply an index of blobs (or other chunked
        blobs) that make up the larger blob. A file that is stored in the system
        may be represented by a blob or a chunked blob.

    \item[Tree] As with Git, a directory that is stored in the system is
        represented by a tree object. The tree refers to the blob, chunked blob,
        or tree that represents each file or subdirectory, along with metadata
        such as the filename.

    \item[Commit] As with Git, a commit represents a given state of the data
        set. It refers to the tree that represents the top-level directory of
        the data set at that state, along with metadata such as author, date,
        and description. It also refers to the previous commit (or commits) that
        represented the previous state of the data set.

    \item[Ref] As with Git, a ref is a reference to a particular commit. A ref
        might represent the current state of a branch of development, or a
        particular state to save for later (a tag).

\end{description}

The DAG begins with refs. Each repository has a list of refs that lead into the
DAG. Each ref refers to a commit. Each commit refers to a tree that represents
the state at the time of committing, plus one or more parent commits. A tree
refers to the blob, chunked blob, or tree that makes up each entry in the
directory. A chunked blob can refer to other chunked blobs or to blobs. And
finally, the blobs are the leaves of the graph. This relationship is illustrated
in \autoref{fig:dia_new_dag}.

\begin{figure}[]
    \centering
        \includegraphics[width=0.5\textwidth]{dia_new_dag}
    \caption{DMV DAG Object Types}
    \label{fig:dia_new_dag}
\end{figure}


Files are split into chunks using a rolling hash algorithm such as Rabin-Karp
fingerprinting\cite{rabin_karp_fingerprinting}. This splits the files into
chunks by content rather than positition, so that identical chunks within files
(and especially different versions of the same file) will be found and stored as
identical objects, regardless of their position within the file. This way,
identical chunks will be naturally de-duplicated by the DAG, and only the
changed portions of files need to be stored as new objects.

%


\section{Working with an Incomplete DAG}

The DAG stores the full history of a data set, and it can be sliced to partition
the data in space and time.

\begin{description}

    \item[Partial history of full data set] Keep a subset of commits, plus all
        trees, blobs, and chunked blob indexes reachable from them
        (\autoref{dia_dmv_dag_slice_partial_history}).

    \item[Full history of part of data set] Keep all commits, but keep only the
        trees, blobs, and chunked blob indexes for certain paths
        (\autoref{dia_dmv_dag_slice_history_of_subset}).

    \item[Full history of metadata] Keep all commits and trees, but
        omit blobs and chunked blob indexes
        (\autoref{dia_dmv_dag_slice_history_of_metadata}).

\end{description}

\newcommand{\slicediagramwidth}{0.45\textwidth}

\begin{figure}

    \centering

    \begin{subfigure}[]{\slicediagramwidth}
        \includegraphics[width=\textwidth]{dia_dmv_dag_slice_partial_history}
        \caption{Partial history of full data set}
        \label{dia_dmv_dag_slice_partial_history}
    \end{subfigure}
    ~
    \begin{subfigure}[]{\slicediagramwidth}
        \includegraphics[width=\textwidth]{dia_dmv_dag_slice_history_of_subset}
        \caption{Full history of part of data set}
        \label{dia_dmv_dag_slice_history_of_subset}
    \end{subfigure}
    ~
    \begin{subfigure}[]{\slicediagramwidth}
        \includegraphics[width=\textwidth]{dia_dmv_dag_slice_history_of_metadata}
        \caption{Full history of metadata}
        \label{dia_dmv_dag_slice_history_of_metadata}
    \end{subfigure}

    \caption{A DMV DAG, sliced in different dimensions}
\end{figure}

A DMV node can use any combination of these slicing techniques to keep only
those objects needed at that location. New commits can still be made to a
partial DAG. A node that stores only part of the data set can create new commits
that represent changes to that portion of the data set by assuming that
everything else remains unchanged. Even a metadata-only node can create new
commits that represent renames and reorganization of the same files.

So the DAG can be spread across many nodes, sliced according to what is needed
at each location. Nodes can keep a record of what objects exist at their
neighbor nodes, and statistics about latency to those nodes, which allow them to
estimate how long it would take to transfer a file that is not currently present
on the system.

Though we did not have time to implement this feature, we are envisioning an
enhanced \lstinline{ls} command output that shows these estimates, as
illustrated in \autoref{example-ls-output}.

\begin{figure}[]
    \caption{Speculative DMV ls output showing remote files}
    \label{example-ls-output}
    \lstinputlisting[nolol]{lst-example-ls-output.txt}
\end{figure}


%
