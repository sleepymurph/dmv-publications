\chapter{Idea: Distributed Media Versioning (DMV)}

\newterm{Distributed Media Versioning (DMV)} is our new low-level distributed
data storage platform. It allows a data set to be replicated or sharded across
many nodes according to the capacity of nodes and the needs of local users. Its
focus is on tracking what data is where, presenting that information to the
user, and making it easy to transfer data to other nodes as desired. The
ultimate goal is to create a new abstraction, of \newterm{many devices, one data
item} in varying states of synchronization.

DMV is a generalized storage platform that places no restriction on file types.
Its data model is a classic hierarchical filesystem, but with history.
Applications on each node can read and write to the files via the filesystem as
normal. DMV is dogmatic about the end-to-end argument \cite{endtoendargument},
that it cannot anticipate all the needs of end users and applications. So it
aims to be as general and neutral as possible, focusing only on storage and
tracking, providing a platform for other applications to build on. DMV stores
files as binary large objects (BLOBs), and it can handle a wide variety of file
sizes, from empty files to files tens of gigabytes in size. It also stores a
wide range of file quantities, from one to hundreds to millions. Where the data
set is too large to fit on one node, it can be spread over many nodes, divided
with the user's guidance according to data locality needs.

DMV is inspired by distributed version control. Its core data structure is a
DAG, based on Git's but modified to store a wider range of file sizes. The key
difference is that large files are broken into smaller chunks (around 64
kilobytes) for easier handling. Breaking files into chunks also allows the data
structure to naturally de-duplicate parts of files that do not change. For
example, if a large media file has its metadata block updated, only the chunk
containing the updated metadata is new. The other chunks will simply be reused.

Like in version control, the DAG structure records all history of the data set
and allows many different branches of development to exist in parallel. This
allows high availability. Any node can always make updates autonomously, without
coordinating with other nodes. Reconciliation of conflicting writes happens
later via merging. DMV only requires a connection to another node during
explicit synchronize operations, and so it is well-suited for applications with
intermittent or high-latency connectivity.

The DAG structure tracks the data set in three dimensions:

\begin{tight_enumerate}
    \item The set of files themselves
    \item The history of the files
    \item The parallel branches of development in the history
\end{tight_enumerate}


TODO: Make everything explicit. Let user decide

TODO: Based on version control but
    - Break up large files
    - Relax requirement to store all

TODO: Concept of data set in multiple dimensions: subset of set, subset of
history


TODO: Envisioned LS output

\begin{lstlisting}[caption=Example ls output]
    -rw-r--r-- 1 user user  121306 Oct 21 18:28 local   filex
    -rw-r--r-- 1 user user   25475 Oct 21 17:52 100ms   filey
    -rw-r--r-- 1 user user   32031 Oct 21 17:52 20min   filez
    -rw-r--r-- 1 user user   74968 Oct 18 17:12 missing filexx
    -rw-r--r-- 1 user user   83977 Sep 22 21:23 unknown fileyy
\end{lstlisting}



\subsection{Main principles}

\begin{itemize}

  \item Data must never be lost accidentally.

  \item However, history may be deliberately truncated to save space, and
    sensitive data may be deliberately redacted.

  \item Data integrity must be verifiable: The system must be able to detect
    errors and, if possible, repair them.

  \item Changes to the dataset should be tracked, versions should be explicitly
    labeled, and history should be kept.

  \item Like with distributed version control, updates can be made independently
    and merged later. Different sites can have different versions. Updates
    (commits) and synchronization are deliberate, explicit, and manual.

\end{itemize}

\section{A Note on the Name DMV}

We chose the name Distributed Media Versioning because it is a concise way to
describe the system, emphasizing its distributed nature, its roots in version
control, and its goal of storing a wide range of media rather than just source
code. The acronym DMV makes for a short and easy-to-type base command for
command line control, in the grand tradition of \lstinline{cvs},
\lstinline{svn}, \lstinline{git}, and \lstinline{hg}. And though in many places
the acronym is associated with a Department of Motor Vehicles, it does not seem
to have any prior conflicting uses in the computing domain (possibly because of
negative associations with the Department of Motor Vehicles). It is also an nod
to Michael's home town of Washington DC, where the Washington metro area in DC,
Maryland, and Virginia is sometimes referred to as "The DMV."
