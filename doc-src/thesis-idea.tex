\chapter{Idea: Distributed Media Versioning (DMV)}

\newterm{Distributed Media Versioning (DMV)} is our new low-level distributed
data storage platform. It allows a data set to be replicated or sharded across
many nodes according to the capacity of nodes and the needs of local users. Its
focus is on tracking what data is where, presenting that information to the
user, and making it easy to transfer data to other nodes as desired. The
ultimate goal is to create a new abstraction, of \newterm{many devices, one data
item} in varying states of synchronization.

% TODO: simple diagram showing nodes and subsets of data


\paragraph{General storage}

DMV is a generalized storage platform that places no restriction on file types.
Its data model is a classic hierarchical filesystem, but with history.
Applications on each node can read and write to the files via the filesystem as
normal. DMV is dogmatic about the end-to-end argument \cite{endtoendargument},
that it cannot anticipate all the needs of end users and applications. So it
aims to be as general and neutral as possible, focusing on the core task of
storage and tracking, and providing a platform for other applications to build
on. DMV stores files as binary large objects (BLOBs), and it can handle a wide
variety of file sizes, from empty files to files tens of gigabytes in size. It
also stores a wide range of file quantities, from one to hundreds to millions.
Where the data set is too large to fit on one node, it can be spread over many
nodes, divided with the user's guidance according to data locality needs.


\paragraph{Based on version control}

DMV is inspired by distributed version control. Its core data structure is a
DAG, based on Git's but modified to store a wider range of file sizes. The key
difference is that large files are broken into smaller chunks (around 64
kilobytes) for easier handling. Breaking files into chunks also allows the data
structure to naturally de-duplicate parts of files that do not change. For
example, if a large media file has its metadata block updated, only the chunk
containing the updated metadata is new. The other chunks will simply be reused.


\paragraph{Always writable}

Like in version control, the DAG structure records all history of the data set
and allows many different branches of development to exist in parallel. This
allows high availability. Any node can always make updates autonomously, without
coordinating with other nodes. Reconciliation of conflicting writes happens
later via merging. DMV only requires a connection to another node during
explicit synchronize operations, and so it is well-suited for applications with
intermittent or high-latency connectivity.


\paragraph{Configurable sharding}

The DAG structure tracks the data set in three dimensions:

\begin{tight_enumerate}
    \item The set of files themselves
    \item The history of the files
    \item The parallel branches of development in the history
\end{tight_enumerate}

Traditional distributed version control systems tend to assume that each replica
has the full history of all files, though not every branch of development. In
contrast, each DMV node can store a subset of the data along any of those
dimensions, configurable by the user. A node could keep the full history of only
a small subset of files, or only the most recent few versions of the full set of
files, or only a few branches, or any combination.

% TODO: Consistent "node" vs "replica"


\paragraph{Explicit operations}

Like with version control, file changes in DMV are explicitly committed by user
command. Synchronization is an explicit command as well. Applications built on
DMV may add daemons to automatically commit and sync, but DMV focuses only on
providing the commands.


\iffalse
TODO: Envisioned LS output

\begin{lstlisting}[float,caption=Example ls output]
    -rw-r--r-- 1 user user  121306 Oct 21 18:28 local   filex
    -rw-r--r-- 1 user user   25475 Oct 21 17:52 100ms   filey
    -rw-r--r-- 1 user user   32031 Oct 21 17:52 20min   filez
    -rw-r--r-- 1 user user   74968 Oct 18 17:12 missing filexx
    -rw-r--r-- 1 user user   83977 Sep 22 21:23 unknown fileyy
\end{lstlisting}
\fi



\subsection{Main principles}

\begin{itemize}

  \item Data must never be lost accidentally.

  \item However, history may be deliberately truncated to save space, and
    sensitive data may be deliberately redacted.

  \item Data integrity must be verifiable: The system must be able to detect
    errors and, if possible, repair them.

  \item Changes to the dataset should be tracked, versions should be explicitly
    labeled, and history should be kept.

  \item Like with distributed version control, updates can be made independently
    and merged later. Different sites can have different versions. Updates
    (commits) and synchronization are deliberate, explicit, and manual.

\end{itemize}

\section{A Note on the Name DMV}

We chose the name Distributed Media Versioning because it is a concise way to
describe the system, emphasizing its distributed nature, its roots in version
control, and its goal of storing a wide range of media rather than just source
code. The acronym DMV makes for a short and easy-to-type base command for
command line control, in the grand tradition of \lstinline{cvs},
\lstinline{svn}, \lstinline{git}, and \lstinline{hg}. And though in many places
the acronym is associated with a Department of Motor Vehicles, it does not seem
to have any prior conflicting uses in the computing domain.\footnote{Possibly
because of negative associations with the Department of Motor Vehicles} It is
also an nod to Michael's home town of Washington DC, where the Washington
metropolitan area is sometimes referred to as "The DMV" as it spills out of the
District of Columbia and into Maryland and Virgina.
