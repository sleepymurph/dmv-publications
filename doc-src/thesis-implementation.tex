\chapter{Implementation}

We have written a DMV prototype as a proof-of-concept. The DMV prototype is
written in the Rust programming language and it runs from the Unix command line,
though it can also be compiled as a library to be used by other applications.
DMV is used on the command line like other version control systems and includes
familiar subcommands such as branch, commit, and checkout
(\autoref{prototype-help-output}\todo{Actually rename the prototype and
recapture output}).

\begin{figure}[h]
    \caption{DMV help output, listing subcommands}
    \label{prototype-help-output}
    \lstinputlisting[nolol,basicstyle=\scriptsize]{lst-prototype-help-output.txt}
\end{figure}



\section{Rust}

The implementation language, Rust, is a new C-like systems language that uses a
sophisticated type system to guarantee memory safety\todo{Cite Rust background},
avoiding data races in concurrent code, as well as the segmentation faults and
buffer overflows that are so easy to write in C. We chose Rust primarily because
it is a compiled language. Compiling to machine code gives us the best chance of
porting DMV to low-powered or mobile devices, and it allows us to compile DMV as
a library.



\section{Working Directory and Object Store}

\towrite{Prototype copies working directory and object store. Disadvantage: disk
space. Could use FUSE}



\section{Chunking algorithm}\label{chunking-algoritm}

Files are broken into chunks using the same rolling hash algorithm used by Gzip
and Rsyncrypto\cite{rsyncrypto_algorithm} to respectively compress and encrypt
files by chunks so that the result is "rsyncable"-- a remote copy of the
compressed or encrypted file can be updated by transferring only those chunks
that have changed.

The algorithm keeps a sum of the previous \num{8196} bytes of input data, and
creates a chunk boundary when that sum is evenly divisible by \num{4096}. We
increased the parameters to yield larger chunks, summing the previous
\num{32768} bytes (\SI{32}{\kibi\byte}) and dividing by \num{16384}
(\SI{16}{\kibi\relax}).

\begin{equation*}
    \left( \sum_{i = n - \num{32768} }^{n}{P_i} \right) \mod \num{16384} = 0
\end{equation*}

This gives a mean chunk size of \SI{52}{\kibi\byte} with a standard deviation of
\SI{21}{\kibi\byte}. The experiments used to measure and tune chunk sizes are
described in \autoref{rolling-hash-exp}.
